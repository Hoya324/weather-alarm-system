name: Deploy Outside Weather to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  EC2_REGION: ap-northeast-2
  ECR_REGISTRY: public.ecr.aws
  ECR_REPOSITORY: j8w6n7e6/gittree/gittree-ecr-repo

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon Public ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build and push Docker images
        id: build
        run: |
          IMAGE_TAG="production-${{ github.run_number }}"
          API_IMAGE_URI=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:api-${IMAGE_TAG}
          BATCH_IMAGE_URI=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:batch-${IMAGE_TAG}
          
          echo "üî® Building API Docker image..."
          docker build -f Dockerfile.api -t ${API_IMAGE_URI} .
          
          echo "üî® Building Batch Docker image..."
          docker build -f Dockerfile.batch -t ${BATCH_IMAGE_URI} .
          
          echo "üì§ Pushing API image to ECR..."
          docker push ${API_IMAGE_URI}
          
          echo "üì§ Pushing Batch image to ECR..."
          docker push ${BATCH_IMAGE_URI}
          
          # Also tag as latest
          docker tag ${API_IMAGE_URI} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:api-latest
          docker tag ${BATCH_IMAGE_URI} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:batch-latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:api-latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:batch-latest
          
          echo "‚úÖ Images pushed successfully"
          echo "API: ${API_IMAGE_URI}"
          echo "Batch: ${BATCH_IMAGE_URI}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Clean up local images
        run: |
          echo "üßπ Cleaning up local build artifacts..."
          docker image prune -f
          docker builder prune -f

  deploy:
    needs: [ build-and-push ]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials for EC2
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.EC2_REGION }}

      - name: Copy configuration files to EC2
        run: |
          echo "üìÅ Preparing configuration files..."
          
          # docker-compose.ymlÏùÑ base64Î°ú Ïù∏ÏΩîÎî©
          DOCKER_COMPOSE_CONTENT=$(base64 -w 0 < docker/docker-compose.yml)
          
          # nginx ÏÑ§Ï†ï ÌååÏùºÎì§ÏùÑ base64Î°ú Ïù∏ÏΩîÎî©
          NGINX_CONF_CONTENT=$(base64 -w 0 < nginx/conf.d/default.conf)
          NGINX_NO_SSL_CONTENT=$(base64 -w 0 < nginx/conf.d/nginx.no-ssl.conf)
          
          # ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú ÏÑ§Ï†ï
          echo "DOCKER_COMPOSE_CONTENT=$DOCKER_COMPOSE_CONTENT" >> $GITHUB_ENV
          echo "NGINX_CONF_CONTENT=$NGINX_CONF_CONTENT" >> $GITHUB_ENV
          echo "NGINX_NO_SSL_CONTENT=$NGINX_NO_SSL_CONTENT" >> $GITHUB_ENV

      - name: Deploy to EC2
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          echo "üöÄ Starting deployment to production..."
          echo "üì¶ Using image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"

          # Create deployment script
          cat > deploy_script.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -e

          echo "üöÄ Starting Outside Weather deployment..."
          echo "Environment: production"
          echo "Docker Repository: $DOCKER_REPO"
          echo "Image Tag: $IMAGE_TAG"

          # ÎîîÎ†âÌÜ†Î¶¨ Ïù¥Îèô ÎòêÎäî ÏÉùÏÑ±
          cd /home/ec2-user/outside-weather-deploy || {
              mkdir -p /home/ec2-user/outside-weather-deploy && cd /home/ec2-user/outside-weather-deploy;
          }

          # .env ÌååÏùº ÌôïÏù∏
          if [ ! -f ".env" ]; then
              echo "‚ùå .env file not found! Please create it manually on EC2."
              exit 1
          fi

          # ÎèôÏ†Å ÌôòÍ≤ΩÎ≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏
          echo "üîÑ Updating dynamic environment variables..."
          
          # IMAGE_TAG ÏóÖÎç∞Ïù¥Ìä∏
          if grep -q "^IMAGE_TAG=" .env; then
              sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=$IMAGE_TAG/" .env
          else
              echo "IMAGE_TAG=$IMAGE_TAG" >> .env
          fi
          
          # ENVIRONMENT ÏóÖÎç∞Ïù¥Ìä∏
          if grep -q "^ENVIRONMENT=" .env; then
              sed -i "s/^ENVIRONMENT=.*/ENVIRONMENT=production/" .env
          else
              echo "ENVIRONMENT=production" >> .env
          fi
          
          # DOCKER_REPO ÏóÖÎç∞Ïù¥Ìä∏
          if grep -q "^DOCKER_REPO=" .env; then
              sed -i "s|^DOCKER_REPO=.*|DOCKER_REPO=$DOCKER_REPO|" .env
          else
              echo "DOCKER_REPO=$DOCKER_REPO" >> .env
          fi
          
          # SPRING_PROFILES_ACTIVE ÏóÖÎç∞Ïù¥Ìä∏ 
          if grep -q "^SPRING_PROFILES_ACTIVE=" .env; then
              sed -i "s/^SPRING_PROFILES_ACTIVE=.*/SPRING_PROFILES_ACTIVE=prod/" .env
          else
              echo "SPRING_PROFILES_ACTIVE=prod" >> .env
          fi
          
          echo "‚úÖ Dynamic environment variables updated"
          echo "üìã Current IMAGE_TAG: $IMAGE_TAG"

          # ÌïÑÏöîÌïú ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ± Î∞è Ï†ïÎ¶¨
          mkdir -p nginx/conf.d logs
          
          # nginx ÏÑ§Ï†ï ÎîîÎ†âÌÜ†Î¶¨ ÏôÑÏ†Ñ Ï†ïÎ¶¨
          echo "üßπ Cleaning nginx configuration directory..."
          rm -rf nginx/conf.d/*
          
          # docker-compose.yml ÌååÏùº ÏÉùÏÑ±
          echo "üìÑ Creating docker-compose.yml..."
          echo "$DOCKER_COMPOSE_CONTENT" | base64 -d > docker-compose.yml

          # nginx ÏÑ§Ï†ï ÌååÏùº ÏÉùÏÑ±
          echo "üìÑ Creating nginx configuration files..."
          echo "$NGINX_CONF_CONTENT" | base64 -d > nginx/conf.d/default.conf.template
          echo "$NGINX_NO_SSL_CONTENT" | base64 -d > nginx/conf.d/nginx.no-ssl.conf.template
          
          # ÌôòÍ≤ΩÎ≥ÄÏàò ÏπòÌôò
          export ENVIRONMENT=production
          envsubst '${ENVIRONMENT}' < nginx/conf.d/default.conf.template > nginx/conf.d/default.conf
          envsubst '${ENVIRONMENT}' < nginx/conf.d/nginx.no-ssl.conf.template > nginx/conf.d/nginx.no-ssl.conf

          # SSL Ïù∏Ï¶ùÏÑú ÌôïÏù∏ Î∞è nginx ÏÑ§Ï†ï Í≤∞Ï†ï
          if [ -d "/etc/letsencrypt/live/git-tree.com" ]; thenif [ -f "nginx/certbot/conf/live/git-tree.com/fullchain.pem" ]; then
              echo "‚úÖ SSL certificate found, using HTTPS configuration"
              # SSL ÏÑ§Ï†ïÏùÑ default.confÎ°ú Î≥µÏÇ¨ÌïòÍ≥† Îã§Î•∏ ÌååÏùºÎì§ÏùÄ Ï†úÍ±∞
              cp nginx/conf.d/default.conf nginx/conf.d/default.conf
              rm -f nginx/conf.d/default.conf nginx/conf.d/nginx.no-ssl.conf nginx/conf.d/*.template
          else
              echo "‚ö†Ô∏è SSL certificate not found, using HTTP configuration"
              # HTTP ÏÑ§Ï†ïÏùÑ default.confÎ°ú Î≥µÏÇ¨ÌïòÍ≥† Îã§Î•∏ ÌååÏùºÎì§ÏùÄ Ï†úÍ±∞
              cp nginx/conf.d/nginx.no-ssl.conf nginx/conf.d/default.conf
              rm -f nginx/conf.d/default.conf nginx/conf.d/nginx.no-ssl.conf nginx/conf.d/*.template
          fi
          
          echo "üìã Final nginx configuration files:"
          ls -la nginx/conf.d/

          echo "üîÑ Stopping existing containers..."
          docker compose down -v 2>/dev/null || docker-compose down -v 2>/dev/null || true

          echo "üßπ Cleaning up old Docker images..."
          # ÌòÑÏû¨ Ïã§Ìñâ Ï§ëÏù¥ÏßÄ ÏïäÏùÄ Outside Weather Ïù¥ÎØ∏ÏßÄÎì§ Ï†ïÎ¶¨ (ÏµúÍ∑º 3Í∞ú Î≤ÑÏ†ÑÎßå Ïú†ÏßÄ)
          echo "üì¶ Cleaning up old Outside Weather images (keeping latest 3 versions)..."
          docker images "$DOCKER_REPO" --format "{{.Repository}}:{{.Tag}}" | \
          grep -E "production-[0-9]+" | \
          sort -V -r | \
          tail -n +4 | \
          xargs -r docker rmi -f 2>/dev/null || true

          # Dangling Ïù¥ÎØ∏ÏßÄ Ï†ïÎ¶¨
          echo "üóëÔ∏è Removing dangling images..."
          docker image prune -f

          # 7Ïùº Ïù¥ÏÉÅÎêú ÎØ∏ÏÇ¨Ïö© Ïù¥ÎØ∏ÏßÄ Ï†ïÎ¶¨
          echo "üóëÔ∏è Removing unused images older than 7 days..."
          docker image prune -a -f --filter "until=168h" || true

          # ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎäî Î≥ºÎ•®Í≥º ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ïÎ¶¨
          echo "üóëÔ∏è Cleaning up unused volumes and networks..."
          docker volume prune -f
          docker network prune -f

          # Ïª®ÌÖåÏù¥ÎÑà Ï†ïÎ¶¨
          echo "üóëÔ∏è Removing stopped containers..."
          docker container prune -f
          
          # Ìè¨Ìä∏ 8080ÏùÑ ÏÇ¨Ïö©ÌïòÎäî ÌîÑÎ°úÏÑ∏Ïä§ ÌôïÏù∏ Î∞è Ï¢ÖÎ£å
          echo "üîç Checking for processes using port 8080..."
          if lsof -i :8080 > /dev/null 2>&1; then
              echo "‚ö†Ô∏è Port 8080 is in use, attempting to free it..."
              docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E "(:8080|0.0.0.0:8080)" | awk '{print $1}' | xargs -r docker stop || true
              docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E "(:8080|0.0.0.0:8080)" | awk '{print $1}' | xargs -r docker rm -f || true
              sleep 5
          fi

          echo "üì• Pulling new images..."
          docker pull $DOCKER_REPO:api-$IMAGE_TAG || exit 1
          docker pull $DOCKER_REPO:batch-$IMAGE_TAG || exit 1

          # ÌôòÍ≤ΩÎ≥ÄÏàò Î°úÎìú
          echo "üîÑ Loading environment variables..."
          
          # .env ÌååÏùºÏùò Í∞Å ÎùºÏù∏ÏùÑ Ï≤òÎ¶¨
          while IFS= read -r line || [ -n "$line" ]; do
              # Ï£ºÏÑùÍ≥º Îπà Ï§Ñ Í±¥ÎÑàÎõ∞Í∏∞
              [[ $line =~ ^[[:space:]]*# ]] && continue
              [[ -z "${line// }" ]] && continue
          
              # Î≥ÄÏàò export
              if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
                  var_name="${BASH_REMATCH[1]}"
                  var_value="${BASH_REMATCH[2]}"
                  export "$var_name"="$var_value"
              fi
          done < .env

          # Ï§ëÏöîÌïú ÌôòÍ≤ΩÎ≥ÄÏàòÎì§ÏùÑ Î™ÖÏãúÏ†ÅÏúºÎ°ú Îã§Ïãú ÏÑ§Ï†ï
          export ENVIRONMENT=production
          export DOCKER_REPO
          export IMAGE_TAG
          export SPRING_PROFILES_ACTIVE=prod

          echo "üöÄ Starting services..."
          echo "üìã Environment variables:"
          echo "  ENVIRONMENT: $ENVIRONMENT"
          echo "  DOCKER_REPO: $DOCKER_REPO"
          echo "  IMAGE_TAG: $IMAGE_TAG"
          echo "  SPRING_PROFILES_ACTIVE: $SPRING_PROFILES_ACTIVE"
          
          # docker-compose Ïã§Ìñâ
          if command -v docker-compose &> /dev/null; then
              echo "üì¶ Using docker-compose..."
              docker-compose up -d
          else
              echo "üì¶ Using docker compose..."
              docker compose up -d
          fi

          echo "‚è≥ Waiting for services to stabilize..."
          sleep 30

          # ÏÑúÎπÑÏä§ ÏÉÅÌÉú ÌôïÏù∏
          echo "üìä Checking service status..."
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          # Ïª®ÌÖåÏù¥ÎÑà Î°úÍ∑∏ ÌôïÏù∏
          for container in outside-weather-mysql-production outside-weather-api-production outside-weather-batch-production; do
              if ! docker ps --filter "name=$container" --filter "status=running" | grep -q $container; then
                  echo "‚ö†Ô∏è Container $container is not running. Checking logs..."
                  docker logs $container --tail 20 2>&1 || echo "Failed to get logs for $container"
              fi
          done

          # ÏµúÏ¢Ö ÎîîÏä§ÌÅ¨ ÏÇ¨Ïö©Îüâ ÌôïÏù∏
          echo "üíæ Current Docker disk usage:"
          docker system df

          # Ìó¨Ïä§Ï≤¥ÌÅ¨
          echo "üîç Running health checks..."
          sleep 10  # Ï∂îÍ∞Ä ÎåÄÍ∏∞ ÏãúÍ∞Ñ
          
          # MySQL Ìó¨Ïä§Ï≤¥ÌÅ¨
          if docker ps --filter "name=outside-weather-mysql-production" --filter "status=running" | grep -q mysql; then
              echo "‚úÖ MySQL is running"
          else
              echo "‚ùå MySQL failed to start"
              docker logs outside-weather-mysql-production --tail 50 2>&1 || echo "Failed to get MySQL logs"
              exit 1
          fi
          
          # API Ìó¨Ïä§Ï≤¥ÌÅ¨
          if docker ps --filter "name=outside-weather-api-production" --filter "status=running" | grep -q outside-weather-api; then
              echo "‚úÖ Outside Weather API application is running"
          
              # Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ìó¨Ïä§Ï≤¥ÌÅ¨
              for i in {1..6}; do
                     curl -f -s --max-time 10 "http://localhost:8080/health" > /dev/null; then
                      echo "‚úÖ API application health check passed"
                      break
                  else
                      echo "‚ö†Ô∏è API application health check failed (attempt $i/6), retrying in 10 seconds..."
                      if [ $i -eq 6 ]; then
                          echo "‚ùå Health check failed after 6 attempts"
                          echo "üìã Trying basic connectivity test..."
                          if curl -f -s --max-time 5 "http://localhost:8080/" > /dev/null; then
                              echo "‚úÖ Basic connectivity works, but health endpoint may not be available"
                          else
                              echo "‚ùå No response from application"
                              echo "üìã API Container logs:"
                              docker logs outside-weather-api-production --tail 50 2>&1 || echo "Failed to get API logs"
                              exit 1
                          fi
                      fi
                      sleep 10
                  fi
              done
          else
              echo "‚ùå Outside Weather API application failed to start"
              echo "üìã API Container logs:"
              docker logs outside-weather-api-production --tail 50 2>&1 || echo "Failed to get API logs"
              exit 1
          fi

          if docker ps --filter "name=outside-weather-batch-production" --filter "status=running" | grep -q outside-weather-batch; then
              echo "‚úÖ Outside Weather Batch application is running"
          else
              echo "‚ùå Outside Weather Batch application failed to start"
              echo "üìã Batch Container logs:"
              docker logs outside-weather-batch-production --tail 50 2>&1 || echo "Failed to get Batch logs"
              exit 1
          fi

          # SSL Ïù∏Ï¶ùÏÑú ÏûêÎèô ÌöçÎìù (Ï≤´ Î∞∞Ìè¨ Ïãú)
          if [ ! -f "nginx/certbot/conf/live/git-tree.com/fullchain.pem" ]; then
              echo "üîê Attempting to obtain SSL certificate..."
              docker compose run --rm certbot certonly \
                  --webroot \
                  --webroot-path=/var/www/certbot \
                  --email hoyana1225@gmail.com \
                  --agree-tos \
                  --no-eff-email \
                  -d git-tree.com \
                  -d www.git-tree.com || echo "‚ö†Ô∏è SSL certificate acquisition failed"
          fi

          echo "‚úÖ Deployment completed successfully!"
          echo "üåê Application URL: https://git-tree.com"
          DEPLOY_EOF

          SCRIPT_CONTENT=$(cat deploy_script.sh | base64 -w 0)

          # Upload and execute deployment script via SSM
          COMMAND_ID=$(aws ssm send-command \
            --region ${{ env.EC2_REGION }} \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              \"echo '$SCRIPT_CONTENT' | base64 -d > /tmp/deploy.sh\",
              \"chmod +x /tmp/deploy.sh\",
              \"export ENVIRONMENT='production'\",
              \"export DOCKER_REPO='${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}'\",
              \"export IMAGE_TAG='$IMAGE_TAG'\",
              \"export DOCKER_COMPOSE_CONTENT='${{ env.DOCKER_COMPOSE_CONTENT }}'\",
              \"export NGINX_CONF_CONTENT='${{ env.NGINX_CONF_CONTENT }}'\",
              \"export NGINX_NO_SSL_CONTENT='${{ env.NGINX_NO_SSL_CONTENT }}'\",
              \"/tmp/deploy.sh\"
            ]" \
            --timeout-seconds 1800 \
            --query 'Command.CommandId' \
            --output text)

          echo "üìã Command ID: $COMMAND_ID"
          echo "command-id=$COMMAND_ID" >> $GITHUB_ENV

      - name: Wait for deployment completion
        run: |
          chmod +x scripts/wait-for-deployment.sh
          ./scripts/wait-for-deployment.sh ${{ env.command-id }} "${{ secrets.EC2_INSTANCE_ID }}"

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          sleep 30

          # Check if the application is responding
          if curl -f -s --max-time 30 "https://git-tree.com/actuator/health" > /dev/null; then
            echo "‚úÖ Application is responding on https://git-tree.com"
          else
            echo "‚ö†Ô∏è Application health check via HTTPS failed, trying HTTP..."
            if curl -f -s --max-time 30 "http://git-tree.com/actuator/health" > /dev/null; then
              echo "‚úÖ Application is responding on http://git-tree.com"
            else
              echo "‚ö†Ô∏è Application health check failed, but deployment may still be starting up"
            fi
          fi

  notification:
    needs: [ build-and-push, deploy ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment notification
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "üéâ Deployment to production successful!"
            echo "üåê Application URL: https://git-tree.com"
            echo "üì¶ Deployed image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
            echo "üî® Build number: ${{ github.run_number }}"
          else
            echo "‚ùå Deployment to production failed!"
            echo "üìã Check the deployment logs for details"
            exit 1
          fi
