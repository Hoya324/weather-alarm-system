name: Deploy Outside Weather to EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  EC2_REGION: ap-northeast-2
  ECR_REGISTRY: public.ecr.aws
  ECR_REPOSITORY: j8w6n7e6/gittree/gittree-ecr-repo

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon Public ECR
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Build and push Docker images
        id: build
        run: |
          IMAGE_TAG="production-${{ github.run_number }}"
          API_IMAGE_URI=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:api-${IMAGE_TAG}
          BATCH_IMAGE_URI=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:batch-${IMAGE_TAG}
          
          echo "ğŸ”¨ Building API Docker image..."
          docker build -f Dockerfile.api -t ${API_IMAGE_URI} .
          
          echo "ğŸ”¨ Building Batch Docker image..."
          docker build -f Dockerfile.batch -t ${BATCH_IMAGE_URI} .
          
          echo "ğŸ“¤ Pushing API image to ECR..."
          docker push ${API_IMAGE_URI}
          
          echo "ğŸ“¤ Pushing Batch image to ECR..."
          docker push ${BATCH_IMAGE_URI}
          
          # Also tag as latest
          docker tag ${API_IMAGE_URI} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:api-latest
          docker tag ${BATCH_IMAGE_URI} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:batch-latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:api-latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:batch-latest
          
          echo "âœ… Images pushed successfully"
          echo "API: ${API_IMAGE_URI}"
          echo "Batch: ${BATCH_IMAGE_URI}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Clean up local images
        run: |
          echo "ğŸ§¹ Cleaning up local build artifacts..."
          docker image prune -f
          docker builder prune -f

  deploy:
    needs: [ build-and-push ]
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials for EC2
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.EC2_REGION }}

      - name: Copy configuration files to EC2
        run: |
          echo "ğŸ“ Preparing configuration files..."
          
          # docker-compose.ymlì„ base64ë¡œ ì¸ì½”ë”©
          DOCKER_COMPOSE_CONTENT=$(base64 -w 0 < docker/docker-compose.yml)
          
          # nginx ì„¤ì • íŒŒì¼ë“¤ì„ base64ë¡œ ì¸ì½”ë”©
          NGINX_CONF_CONTENT=$(base64 -w 0 < nginx/conf.d/default.conf)
          NGINX_NO_SSL_CONTENT=$(base64 -w 0 < nginx/conf.d/nginx.no-ssl.conf)
          
          # í™˜ê²½ë³€ìˆ˜ë¡œ ì„¤ì •
          echo "DOCKER_COMPOSE_CONTENT=$DOCKER_COMPOSE_CONTENT" >> $GITHUB_ENV
          echo "NGINX_CONF_CONTENT=$NGINX_CONF_CONTENT" >> $GITHUB_ENV
          echo "NGINX_NO_SSL_CONTENT=$NGINX_NO_SSL_CONTENT" >> $GITHUB_ENV

      - name: Deploy to EC2
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          echo "ğŸš€ Starting deployment to production..."
          echo "ğŸ“¦ Using image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"

          # Create deployment script
          cat > deploy_script.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -e

          echo "ğŸš€ Starting Outside Weather deployment..."
          echo "Environment: production"
          echo "Docker Repository: $DOCKER_REPO"
          echo "Image Tag: $IMAGE_TAG"

          # ë””ë ‰í† ë¦¬ ì´ë™ ë˜ëŠ” ìƒì„±
          cd /home/ec2-user/outside-weather-deploy || {
              mkdir -p /home/ec2-user/outside-weather-deploy && cd /home/ec2-user/outside-weather-deploy;
          }

          # .env íŒŒì¼ í™•ì¸
          if [ ! -f ".env" ]; then
              echo "âŒ .env file not found! Please create it manually on EC2."
              exit 1
          fi

          # ë™ì  í™˜ê²½ë³€ìˆ˜ ì—…ë°ì´íŠ¸
          echo "ğŸ”„ Updating dynamic environment variables..."
          
          # IMAGE_TAG ì—…ë°ì´íŠ¸
          if grep -q "^IMAGE_TAG=" .env; then
              sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=$IMAGE_TAG/" .env
          else
              echo "IMAGE_TAG=$IMAGE_TAG" >> .env
          fi
          
          # ENVIRONMENT ì—…ë°ì´íŠ¸
          if grep -q "^ENVIRONMENT=" .env; then
              sed -i "s/^ENVIRONMENT=.*/ENVIRONMENT=production/" .env
          else
              echo "ENVIRONMENT=production" >> .env
          fi
          
          # DOCKER_REPO ì—…ë°ì´íŠ¸
          if grep -q "^DOCKER_REPO=" .env; then
              sed -i "s|^DOCKER_REPO=.*|DOCKER_REPO=$DOCKER_REPO|" .env
          else
              echo "DOCKER_REPO=$DOCKER_REPO" >> .env
          fi
          
          # SPRING_PROFILES_ACTIVE ì—…ë°ì´íŠ¸ 
          if grep -q "^SPRING_PROFILES_ACTIVE=" .env; then
              sed -i "s/^SPRING_PROFILES_ACTIVE=.*/SPRING_PROFILES_ACTIVE=prod/" .env
          else
              echo "SPRING_PROFILES_ACTIVE=prod" >> .env
          fi
          
          echo "âœ… Dynamic environment variables updated"
          echo "ğŸ“‹ Current IMAGE_TAG: $IMAGE_TAG"

          # í•„ìš”í•œ ë””ë ‰í† ë¦¬ ìƒì„± ë° ì •ë¦¬
          mkdir -p nginx/conf.d logs
          
          # nginx ì„¤ì • ë””ë ‰í† ë¦¬ ì™„ì „ ì •ë¦¬
          echo "ğŸ§¹ Cleaning nginx configuration directory..."
          rm -rf nginx/conf.d/*
          
          # docker-compose.yml íŒŒì¼ ìƒì„±
          echo "ğŸ“„ Creating docker-compose.yml..."
          echo "$DOCKER_COMPOSE_CONTENT" | base64 -d > docker-compose.yml

          # nginx ì„¤ì • íŒŒì¼ ìƒì„±
          echo "ğŸ“„ Creating nginx configuration files..."
          echo "$NGINX_CONF_CONTENT" | base64 -d > nginx/conf.d/default.conf.template
          echo "$NGINX_NO_SSL_CONTENT" | base64 -d > nginx/conf.d/nginx.no-ssl.conf.template
          
          # í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜
          export ENVIRONMENT=production
          envsubst '${ENVIRONMENT}' < nginx/conf.d/default.conf.template > nginx/conf.d/default.conf
          envsubst '${ENVIRONMENT}' < nginx/conf.d/nginx.no-ssl.conf.template > nginx/conf.d/nginx.no-ssl.conf

          # SSL ì¸ì¦ì„œ í™•ì¸ ë° nginx ì„¤ì • ê²°ì •
          if [ -d "/etc/letsencrypt/live/git-tree.com" ]; thenif [ -f "nginx/certbot/conf/live/git-tree.com/fullchain.pem" ]; then
              echo "âœ… SSL certificate found, using HTTPS configuration"
              # SSL ì„¤ì •ì„ default.confë¡œ ë³µì‚¬í•˜ê³  ë‹¤ë¥¸ íŒŒì¼ë“¤ì€ ì œê±°
              cp nginx/conf.d/default.conf nginx/conf.d/default.conf
              rm -f nginx/conf.d/default.conf nginx/conf.d/nginx.no-ssl.conf nginx/conf.d/*.template
          else
              echo "âš ï¸ SSL certificate not found, using HTTP configuration"
              # HTTP ì„¤ì •ì„ default.confë¡œ ë³µì‚¬í•˜ê³  ë‹¤ë¥¸ íŒŒì¼ë“¤ì€ ì œê±°
              cp nginx/conf.d/nginx.no-ssl.conf nginx/conf.d/default.conf
              rm -f nginx/conf.d/default.conf nginx/conf.d/nginx.no-ssl.conf nginx/conf.d/*.template
          fi
          
          echo "ğŸ“‹ Final nginx configuration files:"
          ls -la nginx/conf.d/

          echo "ğŸ”„ Stopping existing containers..."
          docker compose down -v 2>/dev/null || docker-compose down -v 2>/dev/null || true

          echo "ğŸ§¹ Cleaning up old Docker images..."
          # í˜„ì¬ ì‹¤í–‰ ì¤‘ì´ì§€ ì•Šì€ Outside Weather ì´ë¯¸ì§€ë“¤ ì •ë¦¬ (ìµœê·¼ 3ê°œ ë²„ì „ë§Œ ìœ ì§€)
          echo "ğŸ“¦ Cleaning up old Outside Weather images (keeping latest 3 versions)..."
          docker images "$DOCKER_REPO" --format "{{.Repository}}:{{.Tag}}" | \
          grep -E "production-[0-9]+" | \
          sort -V -r | \
          tail -n +4 | \
          xargs -r docker rmi -f 2>/dev/null || true

          # Dangling ì´ë¯¸ì§€ ì •ë¦¬
          echo "ğŸ—‘ï¸ Removing dangling images..."
          docker image prune -f

          # 7ì¼ ì´ìƒëœ ë¯¸ì‚¬ìš© ì´ë¯¸ì§€ ì •ë¦¬
          echo "ğŸ—‘ï¸ Removing unused images older than 7 days..."
          docker image prune -a -f --filter "until=168h" || true

          # ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë³¼ë¥¨ê³¼ ë„¤íŠ¸ì›Œí¬ ì •ë¦¬
          echo "ğŸ—‘ï¸ Cleaning up unused volumes and networks..."
          docker volume prune -f
          docker network prune -f

          # ì»¨í…Œì´ë„ˆ ì •ë¦¬
          echo "ğŸ—‘ï¸ Removing stopped containers..."
          docker container prune -f
          
          # í¬íŠ¸ 8080ì„ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ í™•ì¸ ë° ì¢…ë£Œ
          echo "ğŸ” Checking for processes using port 8080..."
          if lsof -i :8080 > /dev/null 2>&1; then
              echo "âš ï¸ Port 8080 is in use, attempting to free it..."
              docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E "(:8080|0.0.0.0:8080)" | awk '{print $1}' | xargs -r docker stop || true
              docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep -E "(:8080|0.0.0.0:8080)" | awk '{print $1}' | xargs -r docker rm -f || true
              sleep 5
          fi

          echo "ğŸ“¥ Pulling new images..."
          docker pull $DOCKER_REPO:api-$IMAGE_TAG || exit 1
          docker pull $DOCKER_REPO:batch-$IMAGE_TAG || exit 1

          # í™˜ê²½ë³€ìˆ˜ ë¡œë“œ
          echo "ğŸ”„ Loading environment variables..."
          
          # .env íŒŒì¼ì˜ ê° ë¼ì¸ì„ ì²˜ë¦¬
          while IFS= read -r line || [ -n "$line" ]; do
              # ì£¼ì„ê³¼ ë¹ˆ ì¤„ ê±´ë„ˆë›°ê¸°
              [[ $line =~ ^[[:space:]]*# ]] && continue
              [[ -z "${line// }" ]] && continue
          
              # ë³€ìˆ˜ export
              if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
                  var_name="${BASH_REMATCH[1]}"
                  var_value="${BASH_REMATCH[2]}"
                  export "$var_name"="$var_value"
              fi
          done < .env

          # ì¤‘ìš”í•œ í™˜ê²½ë³€ìˆ˜ë“¤ì„ ëª…ì‹œì ìœ¼ë¡œ ë‹¤ì‹œ ì„¤ì •
          export ENVIRONMENT=production
          export DOCKER_REPO
          export IMAGE_TAG
          export SPRING_PROFILES_ACTIVE=prod

          echo "ğŸš€ Starting services..."
          echo "ğŸ“‹ Environment variables:"
          echo "  ENVIRONMENT: $ENVIRONMENT"
          echo "  DOCKER_REPO: $DOCKER_REPO"
          echo "  IMAGE_TAG: $IMAGE_TAG"
          echo "  SPRING_PROFILES_ACTIVE: $SPRING_PROFILES_ACTIVE"
          
          # docker-compose ì‹¤í–‰
          if command -v docker-compose &> /dev/null; then
              echo "ğŸ“¦ Using docker-compose..."
              docker-compose up -d
          else
              echo "ğŸ“¦ Using docker compose..."
              docker compose up -d
          fi

          echo "â³ Waiting for services to stabilize..."
          sleep 30

          # ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
          echo "ğŸ“Š Checking service status..."
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          # ì»¨í…Œì´ë„ˆ ë¡œê·¸ í™•ì¸
          for container in outside-weather-mysql-production outside-weather-api-production outside-weather-batch-production; do
              if ! docker ps --filter "name=$container" --filter "status=running" | grep -q $container; then
                  echo "âš ï¸ Container $container is not running. Checking logs..."
                  docker logs $container --tail 20 2>&1 || echo "Failed to get logs for $container"
              fi
          done

          # ìµœì¢… ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ í™•ì¸
          echo "ğŸ’¾ Current Docker disk usage:"
          docker system df

          # í—¬ìŠ¤ì²´í¬
          echo "ğŸ” Running health checks..."
          sleep 10  # ì¶”ê°€ ëŒ€ê¸° ì‹œê°„
          
          # MySQL í—¬ìŠ¤ì²´í¬
          if docker ps --filter "name=outside-weather-mysql-production" --filter "status=running" | grep -q mysql; then
              echo "âœ… MySQL is running"
          else
              echo "âŒ MySQL failed to start"
              docker logs outside-weather-mysql-production --tail 50 2>&1 || echo "Failed to get MySQL logs"
              exit 1
          fi
          
          # API í—¬ìŠ¤ì²´í¬
          if docker ps --filter "name=outside-weather-api-production" --filter "status=running" | grep -q outside-weather-api; then
              echo "âœ… Outside Weather API application is running"
          
              # ì• í”Œë¦¬ì¼€ì´ì…˜ í—¬ìŠ¤ì²´í¬
              for i in {1..6}; do
                     curl -f -s --max-time 10 "http://localhost:8080/health" > /dev/null; then
                      echo "âœ… API application health check passed"
                      break
                  else
                      echo "âš ï¸ API application health check failed (attempt $i/6), retrying in 10 seconds..."
                      if [ $i -eq 6 ]; then
                          echo "âŒ Health check failed after 6 attempts"
                          echo "ğŸ“‹ Trying basic connectivity test..."
                          if curl -f -s --max-time 5 "http://localhost:8080/" > /dev/null; then
                              echo "âœ… Basic connectivity works, but health endpoint may not be available"
                          else
                              echo "âŒ No response from application"
                              echo "ğŸ“‹ API Container logs:"
                              docker logs outside-weather-api-production --tail 50 2>&1 || echo "Failed to get API logs"
                              exit 1
                          fi
                      fi
                      sleep 10
                  fi
              done
          else
              echo "âŒ Outside Weather API application failed to start"
              echo "ğŸ“‹ API Container logs:"
              docker logs outside-weather-api-production --tail 50 2>&1 || echo "Failed to get API logs"
              exit 1
          fi

          if docker ps --filter "name=outside-weather-batch-production" --filter "status=running" | grep -q outside-weather-batch; then
              echo "âœ… Outside Weather Batch application is running"
          else
              echo "âŒ Outside Weather Batch application failed to start"
              echo "ğŸ“‹ Batch Container logs:"
              docker logs outside-weather-batch-production --tail 50 2>&1 || echo "Failed to get Batch logs"
              exit 1
          fi

          # SSL ì¸ì¦ì„œ ìë™ íšë“ (ì²« ë°°í¬ ì‹œ)
          if [ ! -f "nginx/certbot/conf/live/git-tree.com/fullchain.pem" ]; then
              echo "ğŸ” Attempting to obtain SSL certificate..."
              docker compose run --rm certbot certonly \
                  --webroot \
                  --webroot-path=/var/www/certbot \
                  --email hoyana1225@gmail.com \
                  --agree-tos \
                  --no-eff-email \
                  -d git-tree.com \
                  -d www.git-tree.com || echo "âš ï¸ SSL certificate acquisition failed"
          fi

          echo "âœ… Deployment completed successfully!"
          echo "ğŸŒ Application URL: https://git-tree.com"
          DEPLOY_EOF

          SCRIPT_CONTENT=$(cat deploy_script.sh | base64 -w 0)

          # Upload and execute deployment script via SSM
          COMMAND_ID=$(aws ssm send-command \
            --region ${{ env.EC2_REGION }} \
            --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              \"echo '$SCRIPT_CONTENT' | base64 -d > /tmp/deploy.sh\",
              \"chmod +x /tmp/deploy.sh\",
              \"export ENVIRONMENT='production'\",
              \"export DOCKER_REPO='${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}'\",
              \"export IMAGE_TAG='$IMAGE_TAG'\",
              \"export DOCKER_COMPOSE_CONTENT='${{ env.DOCKER_COMPOSE_CONTENT }}'\",
              \"export NGINX_CONF_CONTENT='${{ env.NGINX_CONF_CONTENT }}'\",
              \"export NGINX_NO_SSL_CONTENT='${{ env.NGINX_NO_SSL_CONTENT }}'\",
              \"/tmp/deploy.sh\"
            ]" \
            --timeout-seconds 1800 \
            --query 'Command.CommandId' \
            --output text)

          echo "ğŸ“‹ Command ID: $COMMAND_ID"
          echo "command-id=$COMMAND_ID" >> $GITHUB_ENV

      - name: Wait for deployment completion
        run: |
          chmod +x scripts/wait-for-deployment.sh
          ./scripts/wait-for-deployment.sh ${{ env.command-id }} "${{ secrets.EC2_INSTANCE_ID }}"

      - name: Verify deployment
        run: |
          echo "ğŸ” Verifying deployment..."
          sleep 30

          # Check if the application is responding
          if curl -f -s --max-time 30 "https://git-tree.com/actuator/health" > /dev/null; then
            echo "âœ… Application is responding on https://git-tree.com"
          else
            echo "âš ï¸ Application health check via HTTPS failed, trying HTTP..."
            if curl -f -s --max-time 30 "http://git-tree.com/actuator/health" > /dev/null; then
              echo "âœ… Application is responding on http://git-tree.com"
            else
              echo "âš ï¸ Application health check failed, but deployment may still be starting up"
            fi
          fi

  notification:
    needs: [ build-and-push, deploy ]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment notification
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "ğŸ‰ Deployment to production successful!"
            echo "ğŸŒ Application URL: https://git-tree.com"
            echo "ğŸ“¦ Deployed image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
            echo "ğŸ”¨ Build number: ${{ github.run_number }}"
          else
            echo "âŒ Deployment to production failed!"
            echo "ğŸ“‹ Check the deployment logs for details"
            exit 1
          fi
